---
title: "EMD: Projekt z analizy danych"
author: "Zuzanna Kocur, Tomasz Supłat"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    keep_md: yes
    toc: yes
    toc_float: yes
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Opis projektu
Celem projektu była analiza zbioru danych *sledzie.csv* i próba ustalenia wpływu poszczególnych atrybutów na długość śledzi oceanicznych wyławianych w Europie.

Zaczęto od wczytania i wyczyszczenia danych, a następnie przeanalizowano poszczególne atrybuty i ich rozkłady oraz korelacje występujące między nimi. Przygotowano także interaktywny wykres, który przedstawia jak zmieniała się długość badanej ryby w czasie.

Na koniec stworzono model regresji liniowej w celu ustalenia, które atrybuty mają największy wpływ na długość ryby.

###  Wstępne ustawienia

Zapewniono powtarzalność wyników oraz zaimportowano niezbędne biblioteki.

```{r importLibaries}
library(knitr)
library(rmarkdown)
library(ggplot2)
library(corrplot)
library(shiny)
library(caret)
set.seed(42)

```
### Wczytanie i wyczyszczenie danych

W pliku z danymi, brakujące informacje zastąpiono znakiem '?', który przy wczytaniu zastąpiono symbolem **NA**, który reprezentuje w języku *R* brakujące wartości. Wiersze z brakującymi wartościami usunięto i pozostało około 80% wszystkich obserwacji.

```{r readData, results='hold'}
data <- read.csv('sledzie.csv', na.strings = '?')
len_all <- nrow(data)
data_clean <- na.omit(data)
len_not_na <- nrow(data_clean)
print(paste0("Liczba wszystkich obserwacji: ", len_all))
print(paste0("Liczba obserwacji bez brakujacyhc wartości: ", len_not_na))
knitr::kable(summary(data_clean))
```

### Szczegółowa analiza wartości atrybutów

Dla katego atrybutu dokonano analizy na podstawie histogramów przedstawionych ponizej. Dostępność planktonu *Calanus helgolandicus gat. 2* oraz *widłonogów gat. 2* nie przypomina konkretnego rozkladu. Wykresy dla pozostałych planktonów mają wysokie słupki w okolicach zera i długi ogon. Dla niektórych z nich, obserwacji odległych od zera było tak niewiele, ze w ogóle nie widać odpowiadających im słupków.

Natężenie połowów w regionie (**fbar**) i roczny narybek (**recr**) mają zblione rozkłady. Łączne roczne natężenie połowów w regionie (**cumf**) i łączna liczba ryb złowionych w ramach połowu (**totaln**) mają losowe rozkłady, a temperatura przy powierzchni wody (**sst**) oraz poziom zasolenia wody (**sal**) przypominają rozkłady normalne. Rozkład normalny przyjął także atrybut **xmonth**, oznaczający miesiąc połowu, z którego można odczytać że najwięcej obserwacji w zbiorze to obserwacje z cieplejszych miesięcy (lipiec, sierpień, październik). Ostatni atrybut, oscylacja północnoatlantycka (**nao**) przypomina rozkład dwumodalny.

```{r attrAnalysis, echo=FALSE}
columns <- colnames(data_clean)
for (i in 3:length(data_clean)) {
  p1 <- eval(substitute(
    ggplot(data=data_clean,aes(x=data_clean[ ,i]))+ 
      geom_histogram(bins = 30, color="darkblue", fill="lightblue") + 
      ggtitle(columns[i]) + 
      theme(plot.title = element_text(hjust = 0.5)) +
      xlab(colnames(data_clean)[i])
    ,list(i = i)))
  print(p1)
}
```

### Korelacje atrybutów
Przeanalizujmy teraz czy parametry wejsciowe sa ze soba skorelowane.

```{r correlation, echo=FALSE}
corrs <- cor(data.matrix(data_clean))

cex.before <- par("cex")
par(cex = 0.7)
corrplot(corrs[-1,-1],  method = "color",
    addCoef.col="black", tl.col="black",
    order = "hclust", tl.cex = 1/par("cex"),
    cl.cex = 1/par("cex"))
par(cex = cex.before)
```

Jak widac, niektore parametry sa ze soba silnie skorelowane:

* 'lcop1' oraz 'chel1'
* 'lcop2' oraz 'chel2'
* 'lcop2' oraz 'cfin2'
* 'fbar' oraz 'cumf'
* 'totaln' oraz 'cumf'

Parametry 'lcop', 'chel' oraz 'cfin' odpowiadaja poszczegolnym gatunkom planktonu. Prawdopodobnie maja one podobne wymagania co do temperatury i innych czynnikow srodowiskowych, przez co rozwijaja sie podobnie. Nie dziwi rowniez silna korelacja pomiedzy parametrami 'fbar', 'cumf' - oba opisuja natezenie polowow w regionie. Tak samo mozna wytlumaczyc silna korelacje pomiedzy 'totaln' i 'cumf' - odsetek zostawionych ryb i zlowionych ryb. Poniewaz takie parametry moga zaburzac analize danych, usuniemy czesc z nich: 'lcop1', 'lcop2', 'fbar', 'totaln'.


###  Animowane sledzie
Interaktywny wykres przedstawiający zmianę rozmiaru śledzi w czasie.

```{r animation, echo=FALSE}
shinyApp(

  ui = fluidPage(
        h3(
          strong("Interaktywny wykres.", style = "font-si24pt")),
        p("Liczba na suwaku oznacza numer obserwacji w zbiorze danych. Rysunek przyjmuje szerokość odpowiadającą danej obserwacji."),
        sliderInput("slider", label = "", min = 1, max = nrow(data_clean), value = 1, width = "100%"),
        uiOutput('logo')
      ),
     
  server = function(input, output, session) {
    output$logo <- renderUI({
      img(src = "https://cdn.pixabay.com/photo/2014/03/12/01/27/animal-pet-285797_1280.png", width = 20*as.integer(data_clean$length[input$slider]))
    })
  },
)
```

### Regresja

Sprobujemy teraz odpowiedziec na pytanie co jest przyczyna zmian dlugosci sledzia. Do tego celu wytrenujemy model regresyjny.  Dane wejsciowe zostaly podzielone na zbior treningowy (90% danych) i testowy (10% danych). 

``` {r dane}
train_indices <- createDataPartition(data_clean$length, p=0.9, list = FALSE, times=1)
test_indices <- -train_indices

train_set <- data.matrix(data_clean[train_indices, -1])
test_set <- data.matrix(data_clean[test_indices, -1])
```

Na poczatek sprawdzimy dzialanie najprostszego modelu, regresji liniowej. W celu polepszenia wynikow, dane wejsciowe zostaly przeskalowane oraz wycentrowane.

``` {r model}
model <- train(length ~ cfin1+cfin2+chel1+chel2+recr+cumf+sst+sal+xmonth+nao, data = train_set, method="lm", preProcess = c('scale', 'center'))
```

Nastepnie sprawdzmy jak nasz model radzi sobie na zbiorze testowym:

```{r model_summary}
predicted <- predict(model, test_set)
postResample(predicted, data_clean[test_indices, 2])
```

Na koniec zobaczmy jakie zmienne sa najwazniejsze dla naszego modelu:

```{r var_importance}
varImp(model)
```

Jak widzimy, najwazniejsza jest temperatura wody przy powierzchni.


