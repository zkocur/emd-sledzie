---
title: "EMD: Projekt z analizy danych"
author: "Zuzanna Kocur, Tomasz Supłat"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    keep_md: yes
    toc: yes
    toc_float: yes
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

###  Wstępne ustawienia

Zapewniono powtarzalność wyników oraz zaimportowano niezbędne biblioteki.

```{r importLibaries}
library(knitr)
library(rmarkdown)
library(ggplot2)
library(corrplot)
library(shiny)
library(caret)
set.seed(42)

```
### Wczytanie i wyczyszczenie danych

W pliku z danymi, brakujące informacje zastąpiono znakiem '?', który przy wczytaniu zastąpiono symbolem **NA**, który reprezentuje w języku *R* brakujące wartości. Wiersze z brakującymi wartościami usunięto i pozostało około 80% wszystkich obserwacji.

```{r readData, results='hold'}
data <- read.csv('sledzie.csv', na.strings = '?')
len_all <- nrow(data)
data_clean <- na.omit(data)
len_not_na <- nrow(data_clean)
print(paste0("Liczba wszystkich obserwacji: ", len_all))
print(paste0("Liczba obserwacji bez brakujacyhc wartości: ", len_not_na))
knitr::kable(summary(data_clean))
```

### Szczegółowa analiza wartości atrybutów

Dla katego atrybutu dokonano analizy na podstawie histogramów przedstawionych ponizej. Dostępność planktonu *Calanus helgolandicus gat. 2* oraz *widłonogów gat. 2* nie przypomina konkretnego rozkladu. Wykresy dla pozostałych planktonów mają wysokie słupki w okolicach zera i długi ogon. Dla niektórych z nich, obserwacji odległych od zera było tak niewiele, ze w ogóle nie widać odpowiadających im słupków.

Natężenie połowów w regionie (**fbar**) i roczny narybek (**recr**) mają zblione rozkłady. Łączne roczne natężenie połowów w regionie (**cumf**) i łączna liczba ryb złowionych w ramach połowu (**totaln**) mają losowe rozkłady, a temperatura przy powierzchni wody (**sst**) oraz poziom zasolenia wody (**sal**) przypominają rozkłady normalne. Rozkład normalny przyjął także atrybut **xmonth**, oznaczający miesiąc połowu, z którego można odczytać że najwięcej obserwacji w zbiorze to obserwacje z cieplejszych miesięcy (lipiec, sierpień, październik). Ostatni atrybut, oscylacja północnoatlantycka (**nao**) przypomina rozkład dwumodalny.

```{r attrAnalysis, echo=FALSE}
columns <- colnames(data_clean)
for (i in 3:length(data_clean)) {
  p1 <- eval(substitute(
    ggplot(data=data_clean,aes(x=data_clean[ ,i]))+ 
      geom_histogram(bins = 30, color="darkblue", fill="lightblue") + 
      ggtitle(columns[i]) + 
      theme(plot.title = element_text(hjust = 0.5)) +
      xlab(colnames(data_clean)[i])
    ,list(i = i)))
  print(p1)
}
```

### Korelacje atrybutów
A tutaj macierz korelacji. Ladna.

```{r correlation, echo=FALSE}
corrs <- cor(data.matrix(data_clean))

cex.before <- par("cex")
par(cex = 0.7)
corrplot(corrs[-1,-1],  method = "color",
    addCoef.col="black", tl.col="black",
    order = "hclust", tl.cex = 1/par("cex"),
    cl.cex = 1/par("cex"))
par(cex = cex.before)
```

###  Animowane sledzie
Interaktywny wykres przedstawiający zmianę rozmiaru śledzi w czasie.

```{r animation, echo=FALSE}
shinyApp(

  ui = fluidPage(
        h3(
          strong("Interaktywny wykres.", style = "font-si24pt")),
        p("Liczba na suwaku oznacza numer obserwacji w zbiorze danych. Rysunek przyjmuje szerokość odpowiadającą danej obserwacji."),
        sliderInput("slider", label = "", min = 1, max = nrow(data_clean), value = 1, width = "100%"),
        uiOutput('logo')
      ),
     
  server = function(input, output, session) {
    output$logo <- renderUI({
      img(src = "https://cdn.pixabay.com/photo/2014/03/12/01/27/animal-pet-285797_1280.png", width = 20*as.integer(data_clean$length[input$slider]))
    })
  },
)
```

### Regres osobisty

``` {r regrets}
train_indices <- createDataPartition(data_clean$length, p=0.9, list = FALSE, times=1)
test_indices <- -train_indices

train_set <- data.matrix(data_clean[train_indices, -1])
test_set <- data.matrix(data_clean[test_indices, -1])

model <- train(length ~ ., data = train_set, method="lm", preProcess = c('scale', 'center'))
```

```{r model_summary}
predicted <- predict(model, test_set)
postResample(predicted, data_clean[test_indices, 2])
```

```{r var_importance}
varImp(model)
```